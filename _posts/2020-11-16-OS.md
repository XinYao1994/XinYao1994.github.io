## OS ##

- OS software is the minimum amount of software required to allow the computer to function.
- kernel – usually in memory always
- process/thread management
- communications
- memory management
- file management
- monolithic and micro-kernels.

- Manager model, Each manager is independent and maintains tables of information
- Resource allocator model, The emphasis is on providing the services programs need (fair)
- Onion model, Outer layers can access resources contained in inner layers
       - Bare machine > Dispatcher semaphores > Memory > destroy, process, message > device > File

- All in one: MS-DOS (->Exokernels) and Early UNIX
- Separate layers: THE and OS/2
       - This simplifies verification and debugging.
       - Very hard to get the design correct.
       - Can be inefficient – lots of layers to go through to get work done
- Modules: Linux, Windows
- Microkernels: Mach, QNX RT-OS, Exokernels, Sever-Client model

## Memory protection ##
- Operating modes and privileged instructions
- Limited address range
- User mode – execution done on behalf of a user.
- Kernel mode (also monitor mode, supervisor mode, privileged mode or system mode) – execution done on behalf of the
operating system.
- Interrupts, faults, system calls cause the processor to change mode and …
- jump to a particular location.
- Privileged instructions cannot be executed in user mode.
- Devices can be protected using memory protection or privileged instructions

## Time-sharing ##
- Tightly coupled system
     - communication takes place through the shared memory
     - almost all computers now count as tightly coupled systems

## VM ##
- most instructions in a VM must run directly on the hardware
- Hypervisor
   - 0:  implemented in hardware and firmware, it loads at boot time. The guest OSs load into partitions separated by the hardware. They are allocated dedicated resources e.g. processors, memory, devices. Guests OSs are native with a subset of the hardware.
   - 1: they load at boot time and provide the optimised environment to run guest OSs. (kernel mode) VMWare’s ESXi, XenServer
   - 2: run as applications on the host OS. VWmare VBox
- The translation is very simple (and hence efficient).
    - Only translates code which is actually run.
    - Much of the code is exactly the same as the original.
    - The translated code is cached and reused.
    - Uses all sorts of tricks to speed up emulation.
    - Performed very well compared to true hardware virtualization
- Second Level Address Translation
    - determine the guest physical address from the guest virtual address using hardware
    - then turn the guest physical address into the host physical address also using hardware
- Containers: OS level virtualization. Parallels Virtuozzo, OpenVZ, and docker.

## Processes ##
- An instance of a program in execution. it includes code, data, connections (to files, networks, other processes), access to devices.
- thread. Easier to switch between threads. 
   - Easier to create - no system call.
   - Control can be application specific.
- can’t be done with user-level threads
   - splitting work across processors (shared memory multiprocessor, multiple cores)
   - added responsiveness (handle user input while still finishing another function)
   - controlling and monitoring other threads
   - server applications
   - can help program abstraction
- System-level thread
   - Each thread can be treated separately.
   - A thread blocking in the kernel doesn't stop all other threads in the same process.
   - On a multiprocessor (including multi-core) different threads can be scheduled on different processors.
- create process
   - create process system call - takes a program name or a stream with the program data (fork/exec)
       - Traditionally memory was duplicated
       - Share open files as well
       - Open file information blocks will have the count of processes using them increased by one
   - copy process system call - a strange way of doing it but is now very widespread thanks to UNIX
   - create a new terminal session
- Unix Pipes
   - Reading processes are blocked when pipes are empty
   - Writing processes are blocked when pipes are full (65536 bytes on recent Linuxes) 512 bytes
- copy on write 
- vfork: parent process blocks until child finishes or calls exec.
- Condition variables
   - wait before continuing.
   - Rather than continually running checking
- Shared memory
   - explicitly request areas of memory to be shared between processes mmap
- clock interrupt (Preemptive multitasking)
   - control
   - predictability
   - Disadvantages
       - critical sections
       - efficiency
- Cooperative multitasking
   - a process yields its right to run
   - system stops a process when it makes a system call
- Suspended processes are commonly swapped out of real memory.
- first come first served
- Round-robin
- shortest-job first
- time-sharing algorithm
- real-time algorithm for processes where absolute priorities are more important than fairness

- Fixed
   - Rate monotonic (RM) – the shorter the period the higher the priority.
   - Least compute time (LCT) – the shorter the execution time the higher the
   - priority (shortest job first)
- Dynamic
   - Shortest completion time (SCT) – shortest job first with preemption. But this
   - time we have good information on the execution time requirement.
   - Earliest deadline first (EDF) – the process with the closest deadline has the highest priority.
   - Least slack time (LST) – the process with the least slack time has the highest priority.
   - Slack time is the amount of time to the process’s deadline minus the amount of time the process still needs to complete.
- rely on a compare and swap type
instruction, same -> ture, diff -> false
(lecture 12)
- wait-die
   - Process A requests a resource held by process B  If process A is older than process B it waits for the resource. Otherwise process A restarts, process B (the older) continues.
- wound-wait
   - If A is older than B it takes the resource and B restarts.  Otherwise A (the younger) waits for B to release the resource.
- MPI
   - Some way of addressing the message.
   - Some way of transporting the message.
   - Some way of notifying the receiver that a message has arrived.
   - Some way of accessing or depositing the message in the receiver.

## File Systems ##
In UNIX devices are “files” and so are some operating system data structures。
- Unix Semantics: Writes to a file by a user are immediately visible to other users that have this file open.
- Session Semantics: Writes to a file by a user is not visible to other users. Once the file is closed, the changes are visible only to new sessions.
- Create
- Delete
- Move
   - If both locations are on the same device the data doesn’t have to be copied and then the original deleted. Instead change information about the file.
- Copy
- read
   - Sequential access 
   - Direct (or random) access, The read specifies exactly where it wants to get the data from. it could be a byte offset.
- File attributes
   - file name – Many systems use a byte to indicate the file name length and so are limited to 255 characters. There are usually limitations on the characters you can use in filenames.
        - each directory or final filename commonly limited to 255 chars
        - path limit 4096, commonly 255 bytes per path component
   - Identifier – unique tag, usually a number.
   - location –where is the file stored, some pointer to the device (or server) and the positions on the device
   - size of the file –either in bytes, blocks, number of records etc
   - owner information –usually the owner can do anything to a file
   - other access information –who should be allowed to do what
   - dates and times –of creation, access, modification
   - and file types
      - UNIX uses magic numbers on the front of the file data.
- Unix –magic number
- Macintosh –data fork / resource fork
- NTFS –structured object consisting of multiple attributes
- (16) one true file entry in one directory
    - UNIX symbolic (or soft) links
    - There can be a separate table with file information, UNIX and NTFS hard links.
    - Hard links do not have security descriptors; instead, the security descriptor belongs to the original file to which the hard link points.
- Deletion of linked files, Dereference
- (17) inode and MFT
    - First fit – allocate the first spot that is big enough.
    - Next Fit – starting from the location of last placement, allocate the next available spot that is large enough.
    - Best fit – allocate the spot that most closely matches the requirements
    - Worst fit – allocate the largest free spot.
    - Buddy algorithm
- [*] UNIX index block scheme
- Open a file (18)
    - searches for the file with that name verifies that the process has access rights to use the file in the way specified
    - this means we don’t check after this
    - this can be a security problem, sometimes referred to as the TOCTTOU (time of check to time of use) problem 
    - records the fact that the file is open (in the system-wide open file table) and which process is using it 
    - constructs an entry in the process open file table 
    - allocates a buffer for file data
    - returns a pointer (file handle or file descriptor) to be used for future access

(* 22) 

## Memory ##
- Logical address is divided into:
    - Page number –index into a page table which contains base address of each page in physical memory
    - Page offset (displacement) –added to base address to get the physical address.
- Buddy [23] and Slab
    - if you want 65K you get 128K
- Knuth’s 50% rule
    - If there are n segments there are
n/2 holes.
- (ε + β) α + (ε + 2 β)(1 –α)
- Typical TLB caches hold about 128 entries.
    - With 4K pages this is only half a megabyte of memory.
    - As working sets (more on those later) increase this means lots of processes have a real performance hit, memory wise.
-  inverted page tables (24)
- swap
- Each memory access is very probably going to be near another recent memory reference.
- allocate real memory for the page
- move pages from disk into memory
- indicate when the page is now ready
- page fault

- The working set of a process is the collection of pages needed in real memory in order to keep the process running.
   - The trick is getting the window the right size
   - if it is too small not enough pages are included in the working set, if it is too big too many pages areincluded
- Selective algorithm
   - Random
   - FIFO - first in first out
   - Least Recently Used – LRU: a page not used recently will not be used in the near future
   - Least Frequently Used – LFU
   - Most Frequently Used – MFU
   - Optimal If we can see the future, the optimal algorithm replaces a page which is going to be used furthest away in thefuture.
- reference monitor (26, All accesses to objects should be mediated)
   - Privileged instructions
   - Memory protection
   - File system
- Protection Domains, A domain is a collection of ordered pairs
- We want users to have controlled access to resources they don’t have direct access to.
- When an object is created a new column is added and the permissions are set (usually by the creator/owner).
   - The domains are objects as well.
   - This way we can control access to the domains.
   - Transfer to another domain –switch e.g. a process executing in D2 can switch to D3 or D4
   - Copy right “*” signifies the permission can be copied. Can only work on the same object/column.
   - Owner right means any values on the object/column can be changed.
   - The control right allows one domain to remove rights from another domain.
- Only hold information on the rows –each row corresponds to the access rights of a domain over all objects it can use. If the domain has no rights over an object no information is stored. This approach is known as capability lists (**protected object**).
- Only hold information on the columns –each column represents the access rights held over this object. No information is stored about domains that have no access. This approach is known as access lists.
- A capability is a permission to access an object, with domains
- Keeping capabilities safe
    - store all capabilities in protected kernel memory
    - Tagged architectures
    - encrypt capabilities
- Each object has a list of domains and their access rights. This list is an ACL
   - slow down file search operations
   - unnecessarily complex.
   - Many prefer the simplicity of Unix file protection mechanism
- permissions for owner, group and everyone are checked in that order.
- Symmetric algorithms –same key, must be kept secret.
- Asymmetric algorithms use different keys for encrypting and decrypting (one key can be public).
   - the encoding key public –then anyone can encrypt messages but only the holder of the private key can decrypt.
   - the decoding key public – then anyone can decrypt the messages but only the holder of the private key can encrypt them.
- False positive –let someone have access who shouldn’t
- False negative –refuse access to a legitimate user
- Password guessing
   - Don’t write them down.
   - Use mixed upper and lower case letters with numbers and symbols. Better to use the first letters of a phrase
   - Change them occasionally (but not too often).
   - This can be enforced by the system, along with other common password requirements.
   - Usually prevent the user from using an earlier version.
   - Unfortunately this makes it harder to remember and hence the user is more likely to write it down.
   -  Have system produced passwords.
   - Random but pronounceable
   - If people forget their passwords they need the sys admin to give them a new one.
   - This also requires authentication.
   - Many passwords have been bullied out of sys admins over the phone
- Two-factor authentication and One-time passwords
- This is referred to as device probing. A table is compiled of all attached devices. This table is then used in system startup to check the presence of the devices.
- block device, Transfers are buffered through the block buffer cache.
- Character device, 
- Kernel level drivers can commonly access kernel data structures directly
   - slower user level driver
   - Don’t need special permissions to write them.
   - If they crash they don’t affect the kernel.
   - They don’t have uncontrolled access to kernel mode and other drivers

